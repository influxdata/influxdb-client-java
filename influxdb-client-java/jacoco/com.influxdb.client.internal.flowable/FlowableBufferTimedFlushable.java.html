<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FlowableBufferTimedFlushable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">The Java InfluxDB 2.x Client</a> &gt; <a href="index.source.html" class="el_package">com.influxdb.client.internal.flowable</a> &gt; <span class="el_source">FlowableBufferTimedFlushable.java</span></div><h1>FlowableBufferTimedFlushable.java</h1><pre class="source lang-java linenums">package com.influxdb.client.internal.flowable;

import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

import io.reactivex.rxjava3.annotations.NonNull;
import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.core.FlowableTransformer;
import io.reactivex.rxjava3.core.Scheduler;
import io.reactivex.rxjava3.core.Scheduler.Worker;
import io.reactivex.rxjava3.disposables.Disposable;
import io.reactivex.rxjava3.exceptions.Exceptions;
import io.reactivex.rxjava3.functions.Supplier;
import io.reactivex.rxjava3.internal.functions.Functions;
import io.reactivex.rxjava3.internal.operators.flowable.FlowableBufferTimed;
import io.reactivex.rxjava3.internal.operators.flowable.FlowableInternalHelper;
import io.reactivex.rxjava3.internal.queue.MpscLinkedQueue;
import io.reactivex.rxjava3.internal.subscribers.LambdaSubscriber;
import io.reactivex.rxjava3.internal.subscribers.QueueDrainSubscriber;
import io.reactivex.rxjava3.internal.subscriptions.EmptySubscription;
import io.reactivex.rxjava3.internal.subscriptions.SubscriptionHelper;
import io.reactivex.rxjava3.internal.util.QueueDrainHelper;
import io.reactivex.rxjava3.subscribers.SerializedSubscriber;
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

/**
 * Buffered flowable which is able to flush the buffer by the count,
 * time and also by the request by associated {@code publisher}.
 *
 * @param &lt;T&gt; the upstream value type
 * @param &lt;U&gt; the output value type
 * @see FlowableBufferTimed
 */
public final class FlowableBufferTimedFlushable&lt;T, U extends List&lt;? super T&gt;&gt; extends Flowable&lt;U&gt;
        implements FlowableTransformer&lt;T, U&gt; {

    final Publisher&lt;T&gt; source;
    final Publisher&lt;Boolean&gt; flusher;

    final long timespan;
    final long timeskip;
    final TimeUnit unit;
    final Scheduler scheduler;
    final Supplier&lt;U&gt; bufferSupplier;
    final int maxSize;
    final boolean restartTimerOnMaxSize;

    public FlowableBufferTimedFlushable(Publisher&lt;T&gt; source,
                                        Publisher&lt;Boolean&gt; flusher,
                                        long timespan,
                                        TimeUnit unit,
                                        int maxSize,
                                        Scheduler scheduler,
<span class="fc" id="L58">                                        Supplier&lt;U&gt; bufferSupplier) {</span>
<span class="fc" id="L59">        this.source = source;</span>
<span class="fc" id="L60">        this.flusher = flusher;</span>
<span class="fc" id="L61">        this.timespan = timespan;</span>
<span class="fc" id="L62">        this.timeskip = timespan;</span>
<span class="fc" id="L63">        this.unit = unit;</span>
<span class="fc" id="L64">        this.scheduler = scheduler;</span>
<span class="fc" id="L65">        this.bufferSupplier = bufferSupplier;</span>
<span class="fc" id="L66">        this.maxSize = maxSize;</span>
<span class="fc" id="L67">        this.restartTimerOnMaxSize = true;</span>
<span class="fc" id="L68">    }</span>

    @Override
    public @NonNull Publisher&lt;U&gt; apply(@NonNull final Flowable&lt;T&gt; upstream) {
<span class="nc" id="L72">        return new FlowableBufferTimedFlushable&lt;&gt;(upstream, flusher, timeskip, unit, maxSize, scheduler, bufferSupplier);</span>
    }

    @Override
    protected void subscribeActual(@NonNull final Subscriber&lt;? super U&gt; subscriber) {
<span class="fc" id="L77">        Scheduler.Worker w = scheduler.createWorker();</span>
<span class="fc" id="L78">        source.subscribe(new BufferExactBoundedSubscriber&lt;&gt;(</span>
                new SerializedSubscriber&lt;&gt;(subscriber),
                bufferSupplier,
                timespan, unit, maxSize, restartTimerOnMaxSize, w, flusher
        ));
<span class="fc" id="L83">    }</span>

    static final class BufferExactBoundedSubscriber&lt;T, U extends Collection&lt;? super T&gt;&gt;
            extends QueueDrainSubscriber&lt;T, U, U&gt; implements Subscription, Runnable, Disposable {
        final Supplier&lt;U&gt; bufferSupplier;
        final long timespan;
        final TimeUnit unit;
        final int maxSize;
        final boolean restartTimerOnMaxSize;
        final Worker w;

        final Publisher&lt;Boolean&gt; flusher;

        U buffer;

        Disposable timer;

        Subscription upstream;

        long producerIndex;

        long consumerIndex;

        BufferExactBoundedSubscriber(
                Subscriber&lt;? super U&gt; actual,
                Supplier&lt;U&gt; bufferSupplier,
                long timespan, TimeUnit unit, int maxSize,
                boolean restartOnMaxSize, Worker w, Publisher&lt;Boolean&gt; flusher) {
<span class="fc" id="L111">            super(actual, new MpscLinkedQueue&lt;&gt;());</span>
<span class="fc" id="L112">            this.bufferSupplier = bufferSupplier;</span>
<span class="fc" id="L113">            this.timespan = timespan;</span>
<span class="fc" id="L114">            this.unit = unit;</span>
<span class="fc" id="L115">            this.maxSize = maxSize;</span>
<span class="fc" id="L116">            this.restartTimerOnMaxSize = restartOnMaxSize;</span>
<span class="fc" id="L117">            this.w = w;</span>
<span class="fc" id="L118">            this.flusher = flusher;</span>
<span class="fc" id="L119">        }</span>

        @Override
        public void onSubscribe(@NonNull Subscription s) {
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">            if (!SubscriptionHelper.validate(this.upstream, s)) {</span>
<span class="nc" id="L124">                return;</span>
            }
<span class="fc" id="L126">            this.upstream = s;</span>

            U b;

            try {
<span class="fc" id="L131">                b = Objects.requireNonNull(bufferSupplier.get(), &quot;The supplied buffer is null&quot;);</span>
<span class="nc" id="L132">            } catch (Throwable e) {</span>
<span class="nc" id="L133">                Exceptions.throwIfFatal(e);</span>
<span class="nc" id="L134">                w.dispose();</span>
<span class="nc" id="L135">                s.cancel();</span>
<span class="nc" id="L136">                EmptySubscription.error(e, downstream);</span>
<span class="nc" id="L137">                return;</span>
<span class="fc" id="L138">            }</span>

<span class="fc" id="L140">            buffer = b;</span>

<span class="fc" id="L142">            downstream.onSubscribe(this);</span>

<span class="fc" id="L144">            timer = w.schedulePeriodically(this, timespan, timespan, unit);</span>

<span class="fc" id="L146">            s.request(Long.MAX_VALUE);</span>

<span class="fc" id="L148">            flusher.subscribe(new LambdaSubscriber&lt;&gt;(</span>
<span class="fc" id="L149">                    ignore -&gt; run(),</span>
                    Functions.ON_ERROR_MISSING,
                    Functions.EMPTY_ACTION,
                    FlowableInternalHelper.RequestMax.INSTANCE));
<span class="fc" id="L153">        }</span>

        @Override
        public void onNext(T t) {
            U b;
<span class="fc" id="L158">            synchronized (this) {</span>
<span class="fc" id="L159">                b = buffer;</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">                if (b == null) {</span>
<span class="nc" id="L161">                    return;</span>
                }

<span class="fc" id="L164">                b.add(t);</span>

<span class="fc bfc" id="L166" title="All 2 branches covered.">                if (b.size() &lt; maxSize) {</span>
<span class="fc" id="L167">                    return;</span>
                }

<span class="fc" id="L170">                buffer = null;</span>
<span class="fc" id="L171">                producerIndex++;</span>
<span class="fc" id="L172">            }</span>

<span class="pc bpc" id="L174" title="1 of 2 branches missed.">            if (restartTimerOnMaxSize) {</span>
<span class="fc" id="L175">                timer.dispose();</span>
            }

<span class="fc" id="L178">            fastPathOrderedEmitMax(b, false, this);</span>

            try {
<span class="fc" id="L181">                b = Objects.requireNonNull(bufferSupplier.get(), &quot;The supplied buffer is null&quot;);</span>
<span class="nc" id="L182">            } catch (Throwable e) {</span>
<span class="nc" id="L183">                Exceptions.throwIfFatal(e);</span>
<span class="nc" id="L184">                cancel();</span>
<span class="nc" id="L185">                downstream.onError(e);</span>
<span class="nc" id="L186">                return;</span>
<span class="fc" id="L187">            }</span>

<span class="fc" id="L189">            synchronized (this) {</span>
<span class="fc" id="L190">                buffer = b;</span>
<span class="fc" id="L191">                consumerIndex++;</span>
<span class="fc" id="L192">            }</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">            if (restartTimerOnMaxSize) {</span>
<span class="fc" id="L194">                timer = w.schedulePeriodically(this, timespan, timespan, unit);</span>
            }
<span class="fc" id="L196">        }</span>

        @Override
        public void onError(Throwable t) {
<span class="nc" id="L200">            synchronized (this) {</span>
<span class="nc" id="L201">                buffer = null;</span>
<span class="nc" id="L202">            }</span>
<span class="nc" id="L203">            downstream.onError(t);</span>
<span class="nc" id="L204">            w.dispose();</span>
<span class="nc" id="L205">        }</span>

        @Override
        public void onComplete() {
            U b;
<span class="fc" id="L210">            synchronized (this) {</span>
<span class="fc" id="L211">                b = buffer;</span>
<span class="fc" id="L212">                buffer = null;</span>
<span class="fc" id="L213">            }</span>

<span class="pc bpc" id="L215" title="1 of 2 branches missed.">            if (b != null) {</span>
<span class="fc" id="L216">                queue.offer(b);</span>
<span class="fc" id="L217">                done = true;</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">                if (enter()) {</span>
<span class="fc" id="L219">                    QueueDrainHelper.drainMaxLoop(queue, downstream, false, this, this);</span>
                }
<span class="fc" id="L221">                w.dispose();</span>
            }
<span class="fc" id="L223">        }</span>

        @Override
        public boolean accept(Subscriber&lt;? super U&gt; a, U v) {
<span class="fc" id="L227">            a.onNext(v);</span>
<span class="fc" id="L228">            return true;</span>
        }

        @Override
        public void request(long n) {
<span class="fc" id="L233">            requested(n);</span>
<span class="fc" id="L234">        }</span>

        @Override
        public void cancel() {
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">            if (!cancelled) {</span>
<span class="fc" id="L239">                cancelled = true;</span>
<span class="fc" id="L240">                dispose();</span>
            }
<span class="fc" id="L242">        }</span>

        @Override
        public void dispose() {
<span class="fc" id="L246">            synchronized (this) {</span>
<span class="fc" id="L247">                buffer = null;</span>
<span class="fc" id="L248">            }</span>
<span class="fc" id="L249">            upstream.cancel();</span>
<span class="fc" id="L250">            w.dispose();</span>
<span class="fc" id="L251">        }</span>

        @Override
        public boolean isDisposed() {
<span class="nc" id="L255">            return w.isDisposed();</span>
        }

        @Override
        public void run() {
            U next;

            try {
<span class="fc" id="L263">                next = Objects.requireNonNull(bufferSupplier.get(), &quot;The supplied buffer is null&quot;);</span>
<span class="nc" id="L264">            } catch (Throwable e) {</span>
<span class="nc" id="L265">                Exceptions.throwIfFatal(e);</span>
<span class="nc" id="L266">                cancel();</span>
<span class="nc" id="L267">                downstream.onError(e);</span>
<span class="nc" id="L268">                return;</span>
<span class="fc" id="L269">            }</span>

            U current;

<span class="fc" id="L273">            synchronized (this) {</span>
<span class="fc" id="L274">                current = buffer;</span>
<span class="pc bpc" id="L275" title="2 of 4 branches missed.">                if (current == null || producerIndex != consumerIndex) {</span>
<span class="nc" id="L276">                    return;</span>
                }
<span class="fc" id="L278">                buffer = next;</span>
<span class="fc" id="L279">            }</span>

<span class="fc" id="L281">            fastPathOrderedEmitMax(current, false, this);</span>
<span class="fc" id="L282">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>